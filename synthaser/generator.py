"""Rule file generator.

"""

import argparse
import json
import gzip
import shutil
import tempfile

from ftplib import FTP
from pathlib import Path

from synthaser.rpsblast import download as ftp_download


def add_domain_file_argument(parser):
    parser.add_argument(
        "domain_file",
        type=argparse.FileType("r"),
        help="CDD family file generated by rulegen parse",
    )


def add_domain_rule_argument(parser):
    parser.add_argument(
        "rule_file",
        help="synthaser Domain rule file"
    )


def add_convert_subparser(subparsers):
    text = "Convert CDD family names to accessions and vice versa."
    parser = subparsers.add_parser(
        "convert",
        help=text,
        description=text,
        epilog="Cameron L.M. Gilchrist, 2020."
    )
    add_domain_file_argument(parser)
    inputs = parser.add_mutually_exclusive_group()
    inputs.add_argument(
        "-n",
        "--names",
        nargs="+",
        help="Domain family names"
    )
    inputs.add_argument(
        "-a",
        "--accessions",
        nargs="+",
        help="Domain family accessions"
    )


def add_update_domain_subparser(subparsers):
    text = "Add new rules, or update existing rules in a domain rule file."
    parser = subparsers.add_parser("update", help=text, description=text)
    add_domain_file_argument(parser)
    add_domain_rule_argument(parser)

    single = parser.add_argument_group("Add single rule")
    single.add_argument("--type", help="Domain type")
    single.add_argument("--name", help="Domain name")
    single.add_argument("--families", help="CDD family names", nargs="+")

    multi = parser.add_argument_group("Add multiple rules")
    multi.add_argument("--file", type=argparse.FileType("r"), help="Skeleton file")


def add_remove_rule_subparser(subparsers):
    parser = subparsers.add_parser(
        "remove",
        help="Remove domain rules, or specific CDD families from rules.",
        description="Remove domain rules, or specific CDD families from rules."
        " Either remove multiple entire rules, or specify a single rule and multiple"
        " CDD family accessions using --families."
    )
    add_domain_rule_argument(parser)
    parser.add_argument(
        "rules",
        nargs="+",
        help="Rule classes",
    )
    parser.add_argument(
        "--families",
        nargs="+",
        help="CDD family accessions",
    )


def add_download_cdd_subparser(subparsers):
    parser = subparsers.add_parser(
        "download",
        help="Download CDD family information from the NCBI.",
        description="Download CDD family information from the NCBI.",
    )
    parser.add_argument("domain_file", help="Output CDD family file")
    parser.add_argument("--folder", help="Output folder")
    parser.add_argument("--indent", default=2, help="JSON indent level (def. 2)")


def rest(subparsers):
    parser = subparsers.add_parser("rest")
    parser.add_argument(
        "domain_file",
        type=argparse.FileType("r+"),
        help="Domain rule file",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--list",
        help="List all current domain rules",
        action="store_true",
    )
    group.add_argument(
        "--print",
        help="Print given domain entry",
        nargs="+"
    )
    group.add_argument(
        "--update",
        type=argparse.FileType("r"),
        help="Add new or update existing domain rules",
    )
    group.add_argument(
        "--delete",
        help="Delete rules",
        nargs="+",
    )
    group.add_argument(
        "--download",
        help="Download CDD family files",
    )
    group.add_argument(
        "--parse",
        help="Folder containing CDD family files"
    )


def get_parser():
    parser = argparse.ArgumentParser("rulegen")
    subparsers = parser.add_subparsers(dest="subcommand")
    add_convert_subparser(subparsers)
    add_update_domain_subparser(subparsers)
    add_remove_rule_subparser(subparsers)
    add_download_cdd_subparser(subparsers)
    rest(subparsers)
    return parser


# TODO: update to match new schema
def list_domains(d):
    offset = max(len(c["type"]) for c in d["classes"])
    for item in d["classes"]:
        if "families" in item:
            fams = len(item["families"])
        else:
            fams = 0
        line = "{}  {} [{} families]".format(
            item["type"].rjust(offset),
            item["name"],
            fams
        )
        print(line)


def print_domains(d, domains):
    for item in d["classes"]:
        if item["type"] in domains:
            x = json.dumps(item, indent=2)
            print(x)


def delete_domains(d, domains):
    d["classes"] = [
        domain
        for domain in d["classes"]
        if domain["type"] not in domains
    ]


def download_cdd_families(folder):
    """Downloads CDD family information files from NCBI FTP to a folder."""
    folder = Path(folder)

    if not folder.exists() or not folder.is_dir():
        folder.mkdir()

    cddid_gz = folder / "cddid_all.tbl.gz"
    cddid = cddid_gz.with_suffix("")

    bitscore = folder / "bitscore_specific.txt"
    families = folder / "family_superfamily_links"

    print("Connecting to NCBI FTP")
    with FTP("ftp.ncbi.nih.gov") as ftp:
        ftp.login()
        ftp.cwd("pub/mmdb/cdd")

        for path in [cddid_gz, bitscore, families]:
            print(f"Downloading: {path.name}")
            ftp_download(ftp, path.name, path)

        with gzip.open(cddid_gz, "rb") as f_in, cddid.open("wb") as f_out:
            shutil.copyfileobj(f_in, f_out)

        cddid_gz.unlink()


def parse_cdd_families(folder):
    """Generates CDD domain family information database.

    Parses three files downloaded from the NCBI FTP:
    1. cddid_all.tbl: Family information, PSSM length
    2. bitscore_specific.txt: Bitscore thresholds for specific hits
    3. family_superfamily_links: Family-Superfamily relationships

    Then dumps to JSON. File can be used when updating the domain rule
    JSON file with this module.
    """
    folder = Path(folder)

    cddid = folder / "cddid_all.tbl"
    bitscore = folder / "bitscore_specific.txt"
    families = folder / "family_superfamily_links"

    d = {}
    print("Building CDD family file...")
    with cddid.open() as fp:
        parse_cddid(fp, d)
    with bitscore.open() as fp:
        parse_bitscores(fp, d)
    with families.open() as fp:
        parse_families(fp, d)
    return d


def parse_cddid(fp, d):
    """Parses cddid_all.tbl."""
    for line in fp:
        if not line or line.isspace():
            continue
        pssm, accession, name, _, length = line.strip().split("\t")
        d[accession] = dict(
            pssm=pssm,
            accession=accession,
            name=name,
            length=length,
        )


def parse_bitscores(fp, d):
    """Parses bitscore_specific.txt."""
    for line in fp:
        if not line or line.isspace():
            continue
        _, accession, bitscore = line.strip().split("\t")
        d[accession]["bitscore"] = bitscore


def parse_families(fp, d):
    """Parses family_superfamily_links."""
    for line in fp:
        if not line or line.isspace():
            continue
        family, _, superfamily, _ = line.strip().split("\t")
        d[family]["superfamily"] = superfamily


def parse_skeleton(fp):
    """Parse domain rule skeleton file."""
    rules = {}
    for entry in fp.read().split(">"):
        if not entry:
            continue
        header, *families = entry.strip().split("\n")
        acronym, *name = header.split(" ", 1)
        name = name[0] if name else None
        rules[acronym] = dict(name=name, families=families)
    return rules


def update_rule(old, new):
    """Merge families in two rules"""
    old["name"] = new["name"]

    # If rule has no families, set to new
    if "families" not in old:
        old["families"] = new["families"]
        return

    # Otherwise, check for matching rules and update each
    old["families"].update(new["families"])


def update_domains(
    rules,
    domains,
    type=None,
    name=None,
    families=None,
    file=None,
):
    """Adds new, or updates existing domain rules."""
    if file:
        for key, value in parse_skeleton(file).items():
            families = {}
            for family in value["families"]:
                entry = lookup(domains, family)
                accession = entry.pop("accession")
                families[accession] = entry
            value["families"] = families
            if key in rules["rules"]:
                update_rule(rules["rules"][key], value)
            else:
                rules["rules"][key] = value
    else:
        entries = {}
        for family in families:
            entry = lookup(domains, family)
            accession = entry.pop("accession")
            entries[accession] = entry
        if type in rules["rules"]:
            update_rule(rules["rules"][type], entries)
        else:
            rules["rules"][type] = dict(name=name, families=entries)


def lookup(d, key):
    """Finds a family entry in the CDD JSON file."""
    if key in d:
        return d[key]
    for entry in d.values():
        if entry["name"] == key:
            return entry


def find_accession(d, key):
    """Lookup CDD family accession given a name or accession."""
    return lookup(d, key)["accession"]


def convert_domains(d, names=None, accessions=None):
    """Converts a list of CDD family names to accessions, or vice versa."""
    if not (names or accessions):
        raise ValueError("Expected names or accessions")
    return [
        find_accession(d, item)
        for item in (names or accessions)
    ]


def convert(domain_file, names=None, accessions=None):
    """Converts a list of CDD family names to accessions, or vice versa."""
    d = json.load(domain_file)
    results = convert_domains(d, names=names, accessions=accessions)
    for a, b in zip(names or accessions, results):
        if b:
            print(b)
        else:
            print(f"Failed to find: {a}")


def update(
    rule_file,
    domain_file,
    type=None,
    name=None,
    families=None,
    file=None
):
    """Updates rules in a domain rules file.

    Can either provide a single rule by specifying the type, name and CDD families,
    or the path to a skeleton file for multiple rules.

    If a rule is new (does not exist in existing file), it will be added.
    If a rule exists, but there are new families or a new name, it will be updated.
    """
    rule_path = Path(rule_file)
    if rule_path.exists():
        with rule_path.open() as fp:
            df = json.load(fp)
    else:
        df = dict(rules={})
    db = json.load(domain_file)
    update_domains(
        df,
        db,
        type=type,
        name=name,
        families=families,
        file=file,
    )
    with rule_path.open("w") as fp:
        json.dump(df, fp, indent=2)


def remove(rule_file, rules, families):
    """Removes rules or CDD families from a domain rules file.

    If multiple rules are specified, their entire entries will be removed from the file.
    If a single rule, but multiple families are specified, those families will be
    removed from the specific rule.
    """
    rule_path = Path(rule_file)
    with rule_path.open() as fp:
        df = json.load(fp)
    if len(rules) == 1 and families:
        rule = rules[0]
        for family in families:
            df["rules"][rule]["families"].pop(family)
    elif len(rules) > 1:
        for rule in rules:
            df["rules"].pop(rule)
    with rule_path.open("w") as fp:
        json.dump(df, fp, indent=2)


def download(domain_file, folder=None, indent=2):
    """Download CDD family information."""
    if folder:
        download_cdd_families(folder)
        d = parse_cdd_families(folder)
    else:
        print("Using a temporary directory.")
        with tempfile.TemporaryDirectory() as tmpdir:
            download_cdd_families(tmpdir)
            d = parse_cdd_families(tmpdir)
    print(f"Writing: {domain_file}")
    with open(domain_file, "w") as fp:
        json.dump(d, fp, indent=indent)


def main(args):
    if args.subcommand == "convert":
        convert(args.domain_file, names=args.names, accessions=args.accessions)
    elif args.subcommand == "update":
        update(
            args.rule_file,
            args.domain_file,
            type=args.type,
            name=args.name,
            families=args.families,
            file=args.file,
        )
    elif args.subcommand == "remove":
        remove(args.rule_file, args.rules, args.families)
    elif args.subcommand == "download":
        download(args.domain_file, folder=args.folder, indent=args.indent)

    elif args.subcommand == "rest":
        d = json.load(args.domain_file)
        if args.list:
            list_domains(d)
            return
        if args.print:
            print_domains(d, args.print)
            return


if __name__ == "__main__":
    p = get_parser()
    args = p.parse_args()
    main(args)
