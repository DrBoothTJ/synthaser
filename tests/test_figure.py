#!/usr/bin/env python3

"""
Test suite for figure.py
"""

from pathlib import Path

import pytest

from synthaser.figure import Figure, wrap_fasta, _validate_colour
from synthaser.models import Synthase, Domain

TEST_DIR = Path(__file__).resolve().parent


def test_wrap_fasta():
    sequence = "GAGAACGTCGACGTCGATCGATCTAGCTGACAGCTAGCTA"
    wrapped = wrap_fasta(sequence, limit=10)
    assert wrapped == "GAGAACGTCG\nACGTCGATCG\nATCTAGCTGA\nCAGCTAGCTA"


@pytest.mark.parametrize(
    "code,result",
    [
        ("#AAAAAAA", False),  # too long
        ("#AAAAA", False),  # too short
        ("#AAAAAA", True),  # just right
        ("#!@#$%^", False),  # symbols
        ("#AAA", True),  # 3 char codes
        ("AAAAAA", False),  # no hash
    ],
)
def test_validate_colour(code, result):
    assert _validate_colour(code) is result


@pytest.fixture
def domains():
    return [
        Domain(start=0, end=90, type="KS", domain="PKS_KS"),
        Domain(start=10, end=80, type="KS", domain="PKS"),
        Domain(start=100, end=200, type="AT", domain="PKS_AT"),
        Domain(start=130, end=190, type="AT", domain="Acyl_transf_1"),
    ]


@pytest.fixture
def synthase(domains):
    synth = Synthase(
        header="test", sequence="A" * 200, domains=domains, type="PKS", subtype="NR-PKS"
    )
    synth.filter_overlapping_domains()
    return synth


@pytest.fixture
def figure():
    synthases = [
        Synthase(header="hrpks1", sequence="A" * 1000, type="PKS", subtype="HR-PKS"),
        Synthase(header="hrpks2", sequence="A" * 1100, type="PKS", subtype="HR-PKS"),
        Synthase(header="nrpks", sequence="A" * 800, type="PKS", subtype="NR-PKS"),
        Synthase(header="hybrid", sequence="A" * 2000, type="Hybrid", subtype="Hybrid"),
        Synthase(header="nrps", sequence="A" * 1500, type="NRPS", subtype="NRPS"),
    ]

    figure = Figure(synthases=synthases)
    return figure


def test_Figure_init(figure):
    test_figure = Figure()
    assert test_figure.colours == figure.colours

    test_figure = Figure(colours={"ACP": "#FFFFFF", "KS": "#000000"})
    assert test_figure.colours != figure.colours
    assert test_figure.colours["ACP"] == "#FFFFFF"
    assert test_figure.colours["KS"] == "#000000"


def test_Figure_set_colours(figure):
    with pytest.raises(TypeError):
        figure.set_colours(1)

    with pytest.raises(KeyError):
        figure.set_colours({"INVALID": "#000000"})

    with pytest.raises(ValueError):
        figure.set_colours({"KS": "INVALID HEX"})


def test_Figure_generate_synthase_gradient(figure, synthase):
    """Test generation of Synthase gradient based on its Domains.

    Each domain should have 4 stops, the first and last having stop-color="white" to
    create strict edges, the middle two having the colour of the domain as assigned in
    synthaser.COLOURS. The offset attribute should be an integer indicating at what
    percentage of the Synthase length a Domain starts and stops.
    """
    gradient = (
        '<linearGradient id="test_doms" x1="0%" y1="0%" x2="100%" y2="0%">\n'
        f'<stop offset="0%" stop-color="white"/>\n'
        f'<stop offset="0%" stop-color="#08B208"/>\n'
        f'<stop offset="45%" stop-color="#08B208"/>\n'
        f'<stop offset="45%" stop-color="white"/>\n'
        f'<stop offset="50%" stop-color="white"/>\n'
        f'<stop offset="50%" stop-color="#DC0404"/>\n'
        f'<stop offset="100%" stop-color="#DC0404"/>\n'
        f'<stop offset="100%" stop-color="white"/>\n'
        "</linearGradient>"
    )
    assert figure.generate_synthase_gradient(synthase) == gradient


def test_Figure_generate_synthase_polygon(figure, synthase):
    """Test generation of Synthase polygon SVG element.

    This comprises of two SVG elements:
        <text>
            Holds Synthase information. Should have font-size corresponding to argument
            given to Synthase.polygon() and information string generated by
            Synthase.architecture property.

        <polygon>
            Represents the gene arrow. Defines 10 points (coordinate pairs for each of
            the 5 anchors of the polygon) calculated based on scale_factor, sequence
            length and arrow_height.
    """
    # length=200, scale_factor=1, arrow_height=14, info_fsize=12
    assert figure.generate_synthase_polygon(
        synthase, scale_factor=1, arrow_height=14, info_fsize=12
    ) == (
        f'<text dominant-baseline="hanging" font-size="12">test, 200aa, KS-AT</text>'
        f'<polygon id="test" points="0,10.8,190,10.8,200,17.8,190,24.8,0,24.8"'
        f' fill="url(#test_doms)" stroke="black"'
        ' stroke-width="1.5"/>'
    )


def test_Figure_generate_synthase_gradient_no_sequence(figure, synthase):
    synthase.sequence = ""
    with pytest.raises(ValueError):
        figure.generate_synthase_gradient(synthase)


def test_Figure_generate_synthase_polygon_no_sequence(figure, synthase):
    synthase.sequence = ""
    with pytest.raises(ValueError):
        figure.generate_synthase_polygon(synthase)


def test_Figure_eq(figure):
    assert figure == figure
    figure2 = Figure(synthases=figure.synthases[:-1])
    assert figure != figure2
    with pytest.raises(NotImplementedError):
        figure == 1


def test_Figure_serialisation(figure, tmp_path):
    """Test serialisation of Figure to/from JSON."""
    json_file = tmp_path / "json"
    json_file.write_text(figure.to_json())
    with json_file.open() as js:
        figure2 = Figure.from_json(js)
    assert figure == figure2


def test_Figure_get(figure):
    with pytest.raises(KeyError):
        figure["not_in_figure"]
    figure["hrpks1"]


@pytest.mark.parametrize("width,result", [(1000, 0.499), (500, 0.249)])
def test_Figure_scale_factor(figure, width, result):
    with pytest.raises(ValueError):
        figure.calculate_scale_factor(-1)
    assert figure.calculate_scale_factor(width) == result


def test_Figure_scale_factor_no_sequence(figure):
    figure.synthases[1].sequence = ""
    with pytest.raises(ValueError):
        figure.calculate_scale_factor(100)


def test_Figure_iterate_synthase_types(figure):
    """Test grouping of Synthases on this Figure by their subtypes.
    Have to place function call on RHS since Synthases are sorted in-place.
    """
    assert [
        ("Hybrid", [figure.synthases[3]]),
        ("NRPS", [figure.synthases[4]]),
        ("HR-PKS", [figure.synthases[1], figure.synthases[0]]),
        ("NR-PKS", [figure.synthases[2]]),
    ] == list(figure.iterate_synthase_types())


@pytest.fixture
def anid():
    """Returns a Figure from query FASTA and CDSearch results table in tests directory.
    """
    results = TEST_DIR / "anid.tsv"
    fasta = TEST_DIR / "anid.faa"
    figure = Figure.from_cdsearch(fasta, result_file=results)
    return figure


def test_Figure_from_cdsearch(anid):
    """Test instantiation of a Figure from CDSearch results.
    Loads a Figure from JSON generated from the test FASTA/CDSearch results and compares
    to the `anid` Figure fixture.
    """
    test_figure_json = TEST_DIR / "anid.json"
    with test_figure_json.open() as js:
        test_figure = Figure.from_json(js)
    assert str(anid) == str(test_figure)
    assert anid == test_figure


def test_Figure_visualise(anid):
    """Test generation of SVG from a Figure object.

    Reads in the precomputed SVG in the tests directory and compares to the output of
    Figure.visualise() using the anid fixture.
    """
    test_svg = TEST_DIR / "anid.svg"
    with test_svg.open() as handle:
        svg = handle.read()
    assert anid.visualise() == svg


def test_Figure_add_query_sequences(figure):
    """Test adding amino acid sequences to the Figure."""
    with pytest.raises(KeyError):
        figure.add_query_sequences(sequences={"not_in_figure": "ACGT"})
    figure.add_query_sequences(sequences={"hrpks1": "ACGT", "nrps": "ACGT"})
    assert figure["hrpks1"].sequence == "ACGT"
    assert figure["nrps"].sequence == "ACGT"


def test_Figure_sort_synthases_by_length(figure, domains):
    # Test sorting by sequence length
    ordered = [figure.synthases[x] for x in (3, 4, 1, 0, 2)]
    figure.sort_synthases_by_length()
    assert figure.synthases == ordered

    # Clear sequences, add increasing number of domains
    for i, synthase in enumerate(figure.synthases):
        synthase.domains = domains[:i]
        synthase.sequence = ""

    # Test sorting by architecture
    ordered = [figure.synthases[x] for x in (4, 3, 2, 1, 0)]
    figure.sort_synthases_by_length()
    assert figure.synthases == ordered
