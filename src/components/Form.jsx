import { useState } from 'react'
import { DomainList } from './domains/List'
import { RuleList } from './rules/List'
import { RuleTree } from './Tree'
import { v4 as uuidv4 } from 'uuid'
import { find, removeNode, changeNodeAtPath } from 'react-sortable-tree'
import defaultRules from '../rules.js'

/**
 * Creates new Blob object containing serialised ruleset.
 */
function makeBlob(text) {
  return new Blob([text], {type: "text/json"})
}

/**
 * Prompts user download of a Blob object given some filename.
 */
function download(blob, filename) {
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/**
 * The main synthaser rule generator form.
 */
export const Form = () => {
  const [state, setState] = useState({
    domains: [],
    rules: [],
    hierarchy: [],
  })

  /**
   * Prepends a new domain object to the domain array in state.
   *
   * Each new domain has the following properties:
   * @prop {String} uuid - Unique identifier string generated by uuidv4
   * @prop {String} name - Name of domain type
   * @prop {Array} domains - Domain families of this domain type
   */
  const handleAddDomain = () => {
    setState({
      ...state,
      domains: [{ uuid: uuidv4(), name: "", domains: [] }, ...state.domains]
    })
  }

  /**
   * Creates a function which can remove a domain object from state.
   */
  const handleRemoveDomain = index => () => {
    setState({
      ...state,
      domains: state.domains.filter((_, dIndex) => index !== dIndex)
    })
  }

  /**
   * Creates a copy of an object with new key/value pair from an event.
   */
  const handleObjectChange = (obj, event) => {
    const key = event.target.name
    return { ...obj, [key]: event.target.value}
  }

  const findRuleInHierarchy = uuid => {
    return find({
      getNodeKey: ({ node }) => node.key,
      treeData: state.hierarchy,
      searchMethod: ({ node }) => node.key === uuid,
    })
  }

  /**
   * Creates a function which can update domain/rule arrays in state.
   * First layer takes a name ('domains', 'rules') and creates function
   * that takes an array index. This function then creates a function
   * which takes an event, updating the element at the index in the state.
   */
  const updateList = (name, callback) => index => event => {
    const newData = state[name].map((obj, idx) => {
      if (idx !== index) return obj
      let changed = handleObjectChange(obj, event)
      if (callback)
        callback(changed)
      return changed
    })
    setState({ ...state, [name]: newData })
  }
  const handleChangeDomain = updateList("domains")

  const handleChangeRule = uuid => event => {
    let hierarchy
    let rules = state.rules.map(rule => {
      if (rule.uuid !== uuid) return rule

      // Find rule in hierarchy
      rule = handleObjectChange(rule, event)
      let { matches, treeData } = findRuleInHierarchy(rule.uuid) 

      // Update its title
      for (const match of matches) {
        hierarchy = changeNodeAtPath({
          treeData: treeData,
          path: match.path,
          getNodeKey: ({ node }) => node.key,
          newNode: ({ node }) => ({ ...node, title: rule.name })
        })
      }
      return rule
    })

    // Update the state
    setState({ ...state, rules: rules, hierarchy: hierarchy })
  }

  /**
   * Appends a new rule to the rules array in state.
   *
   * Each new rule has the following properties:
   * @prop {String} uuid - Unique identifier string generated by uuidv4
   * @prop {String} name - Name of rule
   * @prop {Array} domains - Domain types used by this rule
   * @prop {Array} filters - Domain type filter rules
   * @prop {Array} renames - Domain type rename rules
   * @prop {String} evaluator - Evaluation logical expression
   */
  const handleAddRule = () => {
    let uuid = uuidv4()
    setState({
      ...state,
      rules: [
        {
          uuid: uuid,
          name: "",
          domains: [],
          filters: [],
          renames: [],
          children: [],
          evaluator: "",
        },
        ...state.rules,
      ],
      hierarchy: [
        ...state.hierarchy,
        {
          title: "",
          key: uuid,
          children: [],
        }
      ]
    })
  }

  /**
   * Generates removal function for a rule at a given index.
   * This function is passed to a <RuleList> argument, which will
   * call it for each <RuleItem> index, so rules can be deleted
   * from within those components by button click.
   */
  const handleRemoveRule = uuid => () => {
    let { matches, treeData } = findRuleInHierarchy(uuid)

    // Remove the node from the hierarchy
    for (const match of matches) {
      treeData = removeNode({
        getNodeKey: ({ node }) => node.key,
        treeData: treeData,
        path: match.path, 
      }).treeData
    }

    // Update state
    setState({
      ...state,
      rules: state.rules.filter(rule => rule.uuid !== uuid),
      hierarchy: treeData || [],
    })
  }

  const handleLoadExample = () => {
    setState(defaultRules)
  }

  /**
   * Serialises ruleset to JSON and prompts user download.
   */
  const handleSaveRule = () => {
    let text = JSON.stringify(state, null, 2)
    let blob = makeBlob(text)
    download(blob, 'synthaser_rules.json')
  }

  /**
   * Loads saved JSON ruleset from file <input> element.
   */
  const handleLoadRule = event => {
    let files = event.target.files
    let file = files[0]
    if (!file) return
    let reader = new FileReader()
    reader.readAsText(file)
    reader.onload = function() {
      let data = JSON.parse(reader.result)
      setState(data)
    }
    reader.onerror = function() {
      console.log(reader.error)
    }
  }

  return (
    <form>
      <div>
        <div className="navbar">
          <b>synthaser rule generator</b>
          <div className="nav-buttons">
            <button
              type="button"
              className="nav-button btn-ex"
              onClick={handleLoadExample}
            >
              Load synthaser rules
            </button>
            <button
              type="button"
              className="nav-button btn-save"
              onClick={handleSaveRule}
            >
              Save rules
            </button>
            <input
              type="file"
              name="file"
              id="rule-upload"
              onChange={handleLoadRule}
            />
            <label
              className="nav-button btn-load"
              htmlFor="rule-upload"
            >Load rules</label>
            <button
              type="button"
              className="nav-button btn-clear"
              onClick={() => setState({ domains: [], rules: [] })}
            >
              Clear all fields
            </button>
          </div>
        </div>
      </div>
      <div className="Container">
        <div className="Pane">
          <h2>Domain types</h2>
          <p>
            Define domain classes (e.g. KS) and select the relevant CDD domain families.
            Search suggestions are shown when at least 3 characters are typed in the box.
          </p>
          <DomainList
            domains={state.domains}
            handleAdd={handleAddDomain}
            handleRemove={handleRemoveDomain}
            handleChange={handleChangeDomain}
          />
        </div>
        <div className="Pane">
          <h2>Classification rules</h2>
          <p>
            Define classification rules (e.g. <i>PKS</i>) by selecting required domains (e.g. <i>KS</i>, <i>AT</i>)
            and their evaluation expression (e.g. 0 and 1).
          </p>
          <p>
            You can specify domain families to use for certain domain types in <b>domain filters</b> (e.g. only
            use the <i>PKS_KS</i> family from <i>KS</i>) as well as renaming rules in <b>rename domains</b>
            (e.g. rename all <i>ACP</i> after <i>A</i> or <i>C</i> domains to <i>T</i>).
          </p>
          <p>
            The <b>evaluation expression</b> of a rule is a logical expression which <em>synthaser</em> uses
            to determine if a sequence contains the correct combination of domains to satisfy the rule.
            For example, given <i>KS</i> and <i>AT</i> domains in the <b>Domain types</b> pane, I could
            create a rule <i>PKS</i> which requires both domains by first selecting <i>KS</i> and <i>AT</i> in
            the <b>Domains</b> field of the rule, then writing <b>0 and 1</b> as the evaluation expression.
            The numbers refer to the index of each domain in the domains list, so this expression essentially
            means '<i>KS</i> and <i>AT</i>'.
          </p>
          <RuleList
            rules={state.rules}
            domains={state.domains}
            handleAdd={handleAddRule}
            handleRemove={handleRemoveRule}
            handleChange={handleChangeRule}
          />
        </div>
        <div className="Pane">
          <h2>Rule hierarchy</h2>
          <p>
            The hierarchy of classification rules.
            Rules are added to the bottom of this hierarchy automatically when they are created in the <b>Classification rules</b> pane.
            They can be freely reordered by dragging and dropping them with your mouse.
          </p>
          <p>
            This determines the order in which rules will be evaluated inside synthaser.
            For example, if we have the three rules <i>PKS</i>, <i>NRPS</i> and <i>HR-PKS</i>, and we set the parent rule of <i>HR-PKS</i> to <i>PKS</i>, synthaser will only evaluate <i>HR-PKS</i> if <i>PKS</i> was satisfied.
          </p>
          <RuleTree
            rules={state.hierarchy || []}
            onChange={treeData => setState({ ...state, hierarchy: treeData })}
          />
        </div>
      </div>
    </form>
  )
}
